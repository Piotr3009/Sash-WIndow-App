"""SVG vector graphics export.

This module provides high-quality SVG export for scalable vector graphics
that can be used in documentation, web pages, and print materials.
"""

from __future__ import annotations

import xml.etree.ElementTree as ET
from typing import Optional, Any

from .base_exporter import BaseExporter
from .renderer import WindowRenderer, ColorScheme
from ..backend.models import Window, Project


class SVGExporter(BaseExporter):
    """Export window designs to SVG vector format.

    Generates clean, scalable SVG files with proper viewBox settings,
    layers implemented as groups, and embedded metadata.
    """

    def __init__(self, output_dir: str = "output/graphics") -> None:
        """Initialize SVG exporter.

        Args:
            output_dir: Directory for output files
        """
        super().__init__(output_dir)
        self.file_extension = ".svg"

    def _hex_to_rgb(self, hex_color: str) -> tuple[int, int, int]:
        """Convert hex color to RGB tuple.

        Args:
            hex_color: Hex color string (e.g., '#FF0000')

        Returns:
            RGB tuple (r, g, b)
        """
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

    def _create_svg_root(self, width: float, height: float) -> ET.Element:
        """Create SVG root element with proper attributes.

        Args:
            width: Canvas width in mm
            height: Canvas height in mm

        Returns:
            SVG root element
        """
        svg = ET.Element(
            'svg',
            {
                'xmlns': 'http://www.w3.org/2000/svg',
                'version': '1.1',
                'viewBox': f'0 0 {width} {height}',
                'width': f'{width}mm',
                'height': f'{height}mm',
            }
        )
        return svg

    def _add_metadata(self, svg: ET.Element, window: Window) -> None:
        """Add metadata to SVG.

        Args:
            svg: SVG root element
            window: Window being exported
        """
        metadata = ET.SubElement(svg, 'metadata')
        title = ET.SubElement(metadata, 'title')
        title.text = f"{window.name} - Sash Window Technical Drawing"

        desc = ET.SubElement(metadata, 'desc')
        desc.text = (
            f"Generated by Skylon Elements Sash Window Designer. "
            f"Project: {self.metadata.get('project_name', 'N/A')}, "
            f"Client: {self.metadata.get('client_name', 'N/A')}"
        )

    def _add_definitions(self, svg: ET.Element) -> None:
        """Add reusable definitions to SVG (patterns, gradients, etc.).

        Args:
            svg: SVG root element
        """
        defs = ET.SubElement(svg, 'defs')

        # Define arrow marker for dimensions
        marker = ET.SubElement(
            defs,
            'marker',
            {
                'id': 'arrow',
                'markerWidth': '10',
                'markerHeight': '10',
                'refX': '5',
                'refY': '3',
                'orient': 'auto',
                'markerUnits': 'strokeWidth'
            }
        )
        ET.SubElement(
            marker,
            'path',
            {
                'd': 'M0,0 L0,6 L9,3 z',
                'fill': '#FF6B6B'
            }
        )

        # Define dotted line style for bars
        style = ET.SubElement(defs, 'style', {'type': 'text/css'})
        style.text = """
        .dotted { stroke-dasharray: 2,2; }
        .dashed { stroke-dasharray: 5,3; }
        """

    def export_window(
        self,
        window: Window,
        output_path: Optional[str] = None,
        **options: Any
    ) -> str:
        """Export a window to SVG format.

        Args:
            window: Window object to export
            output_path: Optional custom output path
            **options: Additional options:
                - include_dimensions (bool): Include dimension lines (default True)
                - include_bars (bool): Include glazing bars (default True)
                - background_color (str): Background color (default 'white')

        Returns:
            Path to generated SVG file
        """
        if not self.validate_window(window):
            raise ValueError("Invalid window object for export")

        # Create renderer and generate geometry
        renderer = WindowRenderer(window, ColorScheme())
        renderer.generate_geometry(
            include_dimensions=options.get("include_dimensions", True),
            include_bars=options.get("include_bars", True)
        )

        # Calculate canvas bounds with padding
        bounds_min, bounds_max = renderer.get_bounds()
        padding = 50.0
        canvas_width = bounds_max.x - bounds_min.x + 2 * padding
        canvas_height = bounds_max.y - bounds_min.y + 2 * padding

        # Create SVG root
        svg = self._create_svg_root(canvas_width, canvas_height)
        self._add_metadata(svg, window)
        self._add_definitions(svg)

        # Add background
        bg_color = options.get("background_color", "white")
        ET.SubElement(
            svg,
            'rect',
            {
                'x': '0',
                'y': '0',
                'width': str(canvas_width),
                'height': str(canvas_height),
                'fill': bg_color
            }
        )

        # Offset for centering
        offset_x = padding - bounds_min.x
        offset_y = padding - bounds_min.y

        # Group all geometry by layer
        layers = {}
        for layer_name in renderer.get_layers():
            group = ET.SubElement(svg, 'g', {'id': f'layer-{layer_name.lower()}'})
            layers[layer_name] = group

        # Export rectangles
        for rect in renderer.rectangles:
            group = layers.get(rect.layer, svg)
            attribs = {
                'x': str(rect.x + offset_x),
                'y': str(rect.y + offset_y),
                'width': str(rect.width),
                'height': str(rect.height),
                'stroke': rect.color,
                'stroke-width': str(rect.linewidth),
                'fill': rect.color if rect.fill else 'none',
            }
            if rect.fill and rect.alpha < 1.0:
                attribs['fill-opacity'] = str(rect.alpha)
            ET.SubElement(group, 'rect', attribs)

        # Export lines
        for line in renderer.lines:
            group = layers.get(line.layer, svg)
            attribs = {
                'x1': str(line.x1 + offset_x),
                'y1': str(line.y1 + offset_y),
                'x2': str(line.x2 + offset_x),
                'y2': str(line.y2 + offset_y),
                'stroke': line.color,
                'stroke-width': str(line.linewidth),
            }
            if line.linestyle == 'dotted':
                attribs['class'] = 'dotted'
            elif line.linestyle == 'dashed':
                attribs['class'] = 'dashed'
            ET.SubElement(group, 'line', attribs)

        # Export dimension lines
        for dim in renderer.dimensions:
            group = layers.get(dim.layer, svg)
            offset_y_dim = dim.offset if dim.y1 == dim.y2 else 0
            offset_x_dim = dim.offset if dim.x1 == dim.x2 else 0

            # Extension lines
            if dim.y1 == dim.y2:  # Horizontal
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x1 + offset_x),
                        'y1': str(dim.y1 + offset_y),
                        'x2': str(dim.x1 + offset_x),
                        'y2': str(dim.y1 + offset_y_dim + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.25'
                    }
                )
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x2 + offset_x),
                        'y1': str(dim.y2 + offset_y),
                        'x2': str(dim.x2 + offset_x),
                        'y2': str(dim.y2 + offset_y_dim + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.25'
                    }
                )
                # Dimension line with arrows
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x1 + offset_x),
                        'y1': str(dim.y1 + offset_y_dim + offset_y),
                        'x2': str(dim.x2 + offset_x),
                        'y2': str(dim.y2 + offset_y_dim + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.35',
                        'marker-start': 'url(#arrow)',
                        'marker-end': 'url(#arrow)'
                    }
                )
            else:  # Vertical
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x1 + offset_x),
                        'y1': str(dim.y1 + offset_y),
                        'x2': str(dim.x1 + offset_x_dim + offset_x),
                        'y2': str(dim.y1 + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.25'
                    }
                )
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x2 + offset_x),
                        'y1': str(dim.y2 + offset_y),
                        'x2': str(dim.x2 + offset_x_dim + offset_x),
                        'y2': str(dim.y2 + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.25'
                    }
                )
                # Dimension line with arrows
                ET.SubElement(
                    group,
                    'line',
                    {
                        'x1': str(dim.x1 + offset_x_dim + offset_x),
                        'y1': str(dim.y1 + offset_y),
                        'x2': str(dim.x2 + offset_x_dim + offset_x),
                        'y2': str(dim.y2 + offset_y),
                        'stroke': dim.color,
                        'stroke-width': '0.35',
                        'marker-start': 'url(#arrow)',
                        'marker-end': 'url(#arrow)'
                    }
                )

        # Export text
        for text in renderer.texts:
            group = layers.get(text.layer, svg)
            attribs = {
                'x': str(text.x + offset_x),
                'y': str(text.y + offset_y),
                'fill': text.color,
                'font-size': str(text.size),
                'font-family': 'Arial, sans-serif',
                'text-anchor': 'middle' if text.halign == 'center' else text.halign,
                'dominant-baseline': 'middle' if text.valign == 'middle' else text.valign,
            }
            if text.rotation != 0:
                attribs['transform'] = f'rotate({text.rotation} {text.x + offset_x} {text.y + offset_y})'

            text_elem = ET.SubElement(group, 'text', attribs)
            text_elem.text = text.text

        # Determine output path
        output_dir = self._ensure_output_dir()
        if output_path:
            file_path = output_path
        else:
            file_path = self._generate_filename(window.name, "vector")

        # Write SVG file with proper formatting
        tree = ET.ElementTree(svg)
        ET.indent(tree, space="  ")
        tree.write(file_path, encoding='utf-8', xml_declaration=True)

        return str(file_path)

    def export_project(
        self,
        project: Project,
        output_path: Optional[str] = None,
        **options: Any
    ) -> str:
        """Export all windows in a project to separate SVG files.

        Args:
            project: Project containing multiple windows
            output_path: Optional custom output directory
            **options: Export options passed to export_window

        Returns:
            Path to output directory containing all SVG files
        """
        self._add_metadata(
            project_name=project.name,
            client_name=project.client_name
        )

        output_dir = self._ensure_output_dir()
        exported_files = []

        for idx, window in enumerate(project.windows, start=1):
            filename = self._generate_filename(
                f"{project.name}_{window.name}",
                f"w{idx:02d}"
            )
            file_path = self.export_window(window, str(filename), **options)
            exported_files.append(file_path)

        return str(output_dir)
